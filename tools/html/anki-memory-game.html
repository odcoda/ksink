<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anki Space Invaders</title>
  <style>
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 20px;
  background: #0a0a1a;
  color: #00ff00;
  font-family: Helvetica, Arial, sans-serif;
  min-height: 100vh;
}

h1 {
  text-align: center;
  font-size: 24px;
  margin-bottom: 20px;
  text-shadow: 0 0 10px #00ff00;
}

.container {
  max-width: 900px;
  margin: 0 auto;
}

.controls {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  align-items: center;
}

.controls button, .controls label {
  background: #1a1a3a;
  border: 2px solid #00ff00;
  color: #00ff00;
  padding: 10px 20px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s;
}

.controls button:hover, .controls label:hover {
  background: #00ff00;
  color: #0a0a1a;
}

.controls input[type="file"] {
  display: none;
}

.deck-select {
  background: #1a1a3a;
  border: 2px solid #00ff00;
  color: #00ff00;
  padding: 10px;
  font-size: 16px;
  flex-grow: 1;
  max-width: 300px;
}

.deck-select option {
  background: #1a1a3a;
}

#gameCanvas {
  display: block;
  margin: 0 auto;
  border: 2px solid #00ff00;
  background: #000011;
}

.question-area {
  background: #1a1a3a;
  border: 2px solid #00ff00;
  padding: 20px;
  margin-top: 20px;
  text-align: center;
}

.question-text {
  font-size: 24px;
  margin-bottom: 20px;
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.answer-input {
  width: 100%;
  max-width: 500px;
  padding: 15px;
  font-size: 16px;
  background: #0a0a1a;
  border: 2px solid #00ff00;
  color: #00ff00;
  text-align: center;
  outline: none;
}

.answer-input:focus {
  box-shadow: 0 0 10px #00ff00;
}

.answer-input::placeholder {
  color: #006600;
}

.stats {
  display: flex;
  justify-content: space-around;
  margin-top: 20px;
  font-size: 18px;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 32px;
  font-weight: bold;
}

.feedback {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 48px;
  font-weight: bold;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
  z-index: 100;
  text-shadow: 0 0 20px currentColor;
}

.feedback.correct {
  color: #00ff00;
}

.feedback.wrong {
  color: #ff0000;
}

.feedback.show {
  opacity: 1;
}

.game-over {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 200;
}

.game-over h2 {
  font-size: 48px;
  color: #ff0000;
  margin-bottom: 20px;
}

.game-over p {
  font-size: 24px;
  margin: 10px;
}

.game-over button {
  margin-top: 30px;
  background: #1a1a3a;
  border: 2px solid #00ff00;
  color: #00ff00;
  padding: 15px 40px;
  font-size: 20px;
  cursor: pointer;
}

.game-over button:hover {
  background: #00ff00;
  color: #0a0a1a;
}

.hidden {
  display: none !important;
}

.instructions {
  text-align: center;
  margin-bottom: 20px;
  opacity: 0.8;
  font-size: 14px;
}

.delete-btn {
  background: #3a1a1a !important;
  border-color: #ff0000 !important;
  color: #ff0000 !important;
}

.delete-btn:hover {
  background: #ff0000 !important;
  color: #0a0a1a !important;
}
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸš€ ANKI SPACE INVADERS ðŸ‘¾</h1>

    <p class="instructions">
      Import an Anki deck (.apkg), then defend Earth by answering flashcards correctly!
      Type the answer and press Enter. Wrong answers let invaders advance!
    </p>

    <div class="controls">
      <label>
        ðŸ“¦ Import Deck
        <input type="file" id="fileInput" accept=".apkg">
      </label>
      <select class="deck-select" id="deckSelect">
        <option value="">-- Select a deck --</option>
      </select>
      <button id="startBtn" disabled>â–¶ Start Game</button>
      <button id="deleteBtn" class="delete-btn hidden">ðŸ—‘ Delete Deck</button>
    </div>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div class="question-area hidden" id="questionArea">
      <div class="question-text" id="questionText">Loading...</div>
      <input type="text" class="answer-input" id="answerInput" placeholder="Type your answer and press Enter..." autocomplete="off">
    </div>

    <div class="stats hidden" id="statsArea">
      <div class="stat">
        <div>Score</div>
        <div class="stat-value" id="scoreDisplay">0</div>
      </div>
      <div class="stat">
        <div>Streak</div>
        <div class="stat-value" id="streakDisplay">0</div>
      </div>
      <div class="stat">
        <div>Cards Left</div>
        <div class="stat-value" id="cardsDisplay">0</div>
      </div>
      <div class="stat">
        <div>Lives</div>
        <div class="stat-value" id="livesDisplay">3</div>
      </div>
    </div>
  </div>

  <div class="feedback" id="feedback"></div>

  <div class="game-over hidden" id="gameOver">
    <h2 id="gameOverTitle">GAME OVER</h2>
    <p>Final Score: <span id="finalScore">0</span></p>
    <p>Cards Reviewed: <span id="cardsReviewed">0</span></p>
    <p>Accuracy: <span id="accuracy">0</span>%</p>
    <button id="playAgainBtn">Play Again</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>

  <script type="module">
const STORAGE_KEY = 'anki_space_invaders_decks';

let gameState = {
  running: false,
  cards: [],
  currentCardIndex: 0,
  score: 0,
  streak: 0,
  lives: 3,
  correct: 0,
  wrong: 0,
  player: { x: 400, y: 360, width: 40, height: 20 },
  bullets: [],
  invaders: [],
  lastInvaderTime: 0,
  invaderSpeed: 0.3
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// DOM elements
const fileInput = document.getElementById('fileInput');
const deckSelect = document.getElementById('deckSelect');
const startBtn = document.getElementById('startBtn');
const deleteBtn = document.getElementById('deleteBtn');
const questionArea = document.getElementById('questionArea');
const questionText = document.getElementById('questionText');
const answerInput = document.getElementById('answerInput');
const statsArea = document.getElementById('statsArea');
const feedback = document.getElementById('feedback');
const gameOver = document.getElementById('gameOver');

// Load sql.js
let SQL;
async function initSQL() {
  SQL = await initSqlJs({
    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
  });
}

// Parse HTML to plain text
function htmlToText(html) {
  const div = document.createElement('div');
  div.innerHTML = html;
  return div.textContent || div.innerText || '';
}

// Parse APKG file
async function parseApkg(file) {
  const zip = await JSZip.loadAsync(file);

  // Find the collection database
  let dbFile = zip.file('collection.anki21') || zip.file('collection.anki2');
  if (!dbFile) {
    throw new Error('Invalid APKG file: no collection database found');
  }

  const dbData = await dbFile.async('arraybuffer');
  const db = new SQL.Database(new Uint8Array(dbData));

  // Get notes
  const notes = db.exec('SELECT flds FROM notes');
  if (!notes.length || !notes[0].values.length) {
    throw new Error('No cards found in deck');
  }

  const cards = notes[0].values.map(row => {
    const fields = row[0].split('\x1f');
    return {
      front: htmlToText(fields[0] || ''),
      back: htmlToText(fields[1] || fields[0] || '')
    };
  }).filter(card => card.front && card.back && card.front !== card.back);

  db.close();
  return cards;
}

// Storage functions
function getStoredDecks() {
  try {
    return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  } catch {
    return {};
  }
}

function saveDeck(name, cards) {
  const decks = getStoredDecks();
  decks[name] = cards;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(decks));
}

function deleteDeck(name) {
  const decks = getStoredDecks();
  delete decks[name];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(decks));
}

function updateDeckList() {
  const decks = getStoredDecks();
  deckSelect.innerHTML = '<option value="">-- Select a deck --</option>';

  Object.keys(decks).forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = `${name} (${decks[name].length} cards)`;
    deckSelect.appendChild(opt);
  });
}

// File import handler
fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    startBtn.textContent = 'â³ Importing...';
    startBtn.disabled = true;

    const cards = await parseApkg(file);
    const name = file.name.replace('.apkg', '');
    saveDeck(name, cards);
    updateDeckList();
    deckSelect.value = name;

    startBtn.textContent = 'â–¶ Start Game';
    startBtn.disabled = false;
    deleteBtn.classList.remove('hidden');

    showFeedback(`Imported ${cards.length} cards!`, 'correct');
  } catch (err) {
    console.error(err);
    showFeedback('Import failed: ' + err.message, 'wrong');
    startBtn.textContent = 'â–¶ Start Game';
    startBtn.disabled = true;
  }

  fileInput.value = '';
});

// Deck selection handler
deckSelect.addEventListener('change', () => {
  const selected = deckSelect.value;
  startBtn.disabled = !selected;
  deleteBtn.classList.toggle('hidden', !selected);
});

// Delete deck handler
deleteBtn.addEventListener('click', () => {
  const selected = deckSelect.value;
  if (selected && confirm(`Delete deck "${selected}"?`)) {
    deleteDeck(selected);
    updateDeckList();
    startBtn.disabled = true;
    deleteBtn.classList.add('hidden');
  }
});

// Show feedback
function showFeedback(text, type) {
  feedback.textContent = text;
  feedback.className = `feedback ${type} show`;
  setTimeout(() => feedback.classList.remove('show'), 1000);
}

// Shuffle array
function shuffle(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Start game
function startGame() {
  const deckName = deckSelect.value;
  const decks = getStoredDecks();
  const cards = decks[deckName];

  if (!cards || !cards.length) {
    showFeedback('No cards in deck!', 'wrong');
    return;
  }

  gameState = {
    running: true,
    cards: shuffle(cards),
    currentCardIndex: 0,
    score: 0,
    streak: 0,
    lives: 3,
    correct: 0,
    wrong: 0,
    player: { x: 400, y: 360, width: 40, height: 20 },
    bullets: [],
    invaders: [],
    lastInvaderTime: Date.now(),
    invaderSpeed: 0.3
  };

  questionArea.classList.remove('hidden');
  statsArea.classList.remove('hidden');
  gameOver.classList.add('hidden');
  startBtn.disabled = true;
  deckSelect.disabled = true;
  deleteBtn.classList.add('hidden');

  showNextCard();
  updateStats();
  answerInput.focus();

  requestAnimationFrame(gameLoop);
}

// Show next card
function showNextCard() {
  if (gameState.currentCardIndex >= gameState.cards.length) {
    endGame(true);
    return;
  }

  const card = gameState.cards[gameState.currentCardIndex];
  questionText.textContent = card.front;
  answerInput.value = '';
}

// Check answer
function checkAnswer() {
  const userAnswer = answerInput.value.trim().toLowerCase();
  const card = gameState.cards[gameState.currentCardIndex];
  const correctAnswer = card.back.trim().toLowerCase();

  // Allow for partial matches and common variations
  const isCorrect = userAnswer === correctAnswer ||
    correctAnswer.includes(userAnswer) && userAnswer.length >= correctAnswer.length * 0.7;

  if (isCorrect) {
    gameState.correct++;
    gameState.streak++;
    gameState.score += 100 + (gameState.streak * 10);

    // Fire bullet
    gameState.bullets.push({
      x: gameState.player.x + gameState.player.width / 2,
      y: gameState.player.y,
      speed: 8
    });

    showFeedback('CORRECT! +' + (100 + gameState.streak * 10), 'correct');
  } else {
    gameState.wrong++;
    gameState.streak = 0;
    gameState.lives--;

    // Show correct answer
    showFeedback(`Wrong! Answer: ${card.back}`, 'wrong');

    if (gameState.lives <= 0) {
      endGame(false);
      return;
    }
  }

  gameState.currentCardIndex++;
  updateStats();

  setTimeout(() => {
    showNextCard();
    answerInput.focus();
  }, 500);
}

// Update stats display
function updateStats() {
  document.getElementById('scoreDisplay').textContent = gameState.score;
  document.getElementById('streakDisplay').textContent = gameState.streak;
  document.getElementById('cardsDisplay').textContent =
    gameState.cards.length - gameState.currentCardIndex;
  document.getElementById('livesDisplay').textContent = gameState.lives;
}

// End game
function endGame(won) {
  gameState.running = false;

  const total = gameState.correct + gameState.wrong;
  const accuracy = total > 0 ? Math.round((gameState.correct / total) * 100) : 0;

  document.getElementById('gameOverTitle').textContent = won ? 'VICTORY!' : 'GAME OVER';
  document.getElementById('gameOverTitle').style.color = won ? '#00ff00' : '#ff0000';
  document.getElementById('finalScore').textContent = gameState.score;
  document.getElementById('cardsReviewed').textContent = total;
  document.getElementById('accuracy').textContent = accuracy;

  gameOver.classList.remove('hidden');
  questionArea.classList.add('hidden');
  startBtn.disabled = false;
  deckSelect.disabled = false;
  if (deckSelect.value) deleteBtn.classList.remove('hidden');
}

// Draw player ship
function drawPlayer() {
  ctx.fillStyle = '#00ff00';
  ctx.beginPath();
  ctx.moveTo(gameState.player.x + gameState.player.width / 2, gameState.player.y);
  ctx.lineTo(gameState.player.x, gameState.player.y + gameState.player.height);
  ctx.lineTo(gameState.player.x + gameState.player.width, gameState.player.y + gameState.player.height);
  ctx.closePath();
  ctx.fill();

  // Engine glow
  ctx.fillStyle = '#ffff00';
  ctx.fillRect(
    gameState.player.x + gameState.player.width / 2 - 5,
    gameState.player.y + gameState.player.height,
    10,
    5 + Math.random() * 5
  );
}

// Draw invaders
function drawInvaders() {
  gameState.invaders.forEach(inv => {
    ctx.fillStyle = inv.color;

    // Draw pixelated invader
    const size = 8;
    const pattern = [
      [0,0,1,0,0,0,0,0,1,0,0],
      [0,0,0,1,0,0,0,1,0,0,0],
      [0,0,1,1,1,1,1,1,1,0,0],
      [0,1,1,0,1,1,1,0,1,1,0],
      [1,1,1,1,1,1,1,1,1,1,1],
      [1,0,1,1,1,1,1,1,1,0,1],
      [1,0,1,0,0,0,0,0,1,0,1],
      [0,0,0,1,1,0,1,1,0,0,0]
    ];

    const startX = inv.x - (pattern[0].length * size) / 2;
    const startY = inv.y;

    pattern.forEach((row, py) => {
      row.forEach((cell, px) => {
        if (cell) {
          ctx.fillRect(startX + px * size, startY + py * size, size - 1, size - 1);
        }
      });
    });
  });
}

// Draw bullets
function drawBullets() {
  ctx.fillStyle = '#ffff00';
  gameState.bullets.forEach(bullet => {
    ctx.fillRect(bullet.x - 2, bullet.y, 4, 10);
  });
}

// Draw stars
let stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    size: Math.random() * 2 + 0.5,
    speed: Math.random() * 0.5 + 0.1
  });
}

function drawStars() {
  ctx.fillStyle = '#ffffff';
  stars.forEach(star => {
    ctx.globalAlpha = 0.3 + Math.random() * 0.7;
    ctx.fillRect(star.x, star.y, star.size, star.size);
    star.y += star.speed;
    if (star.y > canvas.height) {
      star.y = 0;
      star.x = Math.random() * canvas.width;
    }
  });
  ctx.globalAlpha = 1;
}

// Draw HUD
function drawHUD() {
  ctx.fillStyle = '#00ff00';
  ctx.font = '16px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`SCORE: ${gameState.score}`, 10, 25);
  ctx.fillText(`STREAK: ${gameState.streak}`, 10, 45);

  ctx.textAlign = 'right';
  ctx.fillText(`LIVES: ${'â™¥'.repeat(gameState.lives)}`, canvas.width - 10, 25);
  ctx.fillText(`CARDS: ${gameState.cards.length - gameState.currentCardIndex}`, canvas.width - 10, 45);
}

// Update game state
function update() {
  // Move bullets
  gameState.bullets = gameState.bullets.filter(bullet => {
    bullet.y -= bullet.speed;
    return bullet.y > 0;
  });

  // Spawn invaders
  const now = Date.now();
  const spawnRate = Math.max(2000 - gameState.score * 2, 800);
  if (now - gameState.lastInvaderTime > spawnRate && gameState.invaders.length < 8) {
    gameState.invaders.push({
      x: Math.random() * (canvas.width - 100) + 50,
      y: -50,
      color: ['#ff0066', '#ff6600', '#9900ff', '#00ffff'][Math.floor(Math.random() * 4)]
    });
    gameState.lastInvaderTime = now;
  }

  // Move invaders
  const speed = gameState.invaderSpeed + (gameState.score / 5000);
  gameState.invaders.forEach(inv => {
    inv.y += speed;
  });

  // Check bullet-invader collisions
  gameState.bullets.forEach((bullet, bi) => {
    gameState.invaders.forEach((inv, ii) => {
      const dx = Math.abs(bullet.x - inv.x);
      const dy = Math.abs(bullet.y - inv.y - 30);
      if (dx < 40 && dy < 40) {
        gameState.bullets.splice(bi, 1);
        gameState.invaders.splice(ii, 1);
        gameState.score += 25;
      }
    });
  });

  // Check if invaders reached bottom
  gameState.invaders = gameState.invaders.filter(inv => {
    if (inv.y > canvas.height - 50) {
      gameState.lives--;
      updateStats();
      if (gameState.lives <= 0) {
        endGame(false);
      }
      return false;
    }
    return true;
  });

  // Move player toward invaders (auto-aim)
  if (gameState.invaders.length > 0) {
    const nearestInvader = gameState.invaders.reduce((a, b) =>
      a.y > b.y ? a : b
    );
    const targetX = nearestInvader.x - gameState.player.width / 2;
    gameState.player.x += (targetX - gameState.player.x) * 0.05;
  }
}

// Main game loop
function gameLoop() {
  if (!gameState.running) return;

  // Clear canvas
  ctx.fillStyle = '#000011';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawStars();
  drawInvaders();
  drawBullets();
  drawPlayer();
  drawHUD();

  update();

  requestAnimationFrame(gameLoop);
}

// Draw initial screen
function drawIdleScreen() {
  ctx.fillStyle = '#000011';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawStars();

  ctx.fillStyle = '#00ff00';
  ctx.font = '24px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('IMPORT AN ANKI DECK TO BEGIN', canvas.width / 2, canvas.height / 2 - 20);
  ctx.font = '16px monospace';
  ctx.fillText('Answer flashcards to fire at invaders!', canvas.width / 2, canvas.height / 2 + 20);

  if (!gameState.running) {
    requestAnimationFrame(drawIdleScreen);
  }
}

// Event listeners
startBtn.addEventListener('click', startGame);
document.getElementById('playAgainBtn').addEventListener('click', startGame);

answerInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && gameState.running) {
    checkAnswer();
  }
});

// Initialize
async function init() {
  await initSQL();
  updateDeckList();
  drawIdleScreen();

  // Select first deck if available
  const decks = getStoredDecks();
  const deckNames = Object.keys(decks);
  if (deckNames.length > 0) {
    deckSelect.value = deckNames[0];
    startBtn.disabled = false;
    deleteBtn.classList.remove('hidden');
  }
}

init();
  </script>
</body>
</html>
